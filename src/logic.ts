import pkg from '../package.json';
import { AbiExporterConfigEntry } from './types.js';
import { FormatTypes, Interface } from '@ethersproject/abi';
import deleteEmpty from 'delete-empty';
import fs from 'fs';
import { HardhatPluginError } from 'hardhat/plugins';
import { HookContext } from 'hardhat/types/hooks';
import path from 'path';

const TAG = `// this file was automatically generated by ${pkg.name} - do not modify`;

export function abiToTs(json: string): string {
  return `${TAG}\nexport default ${json} as const;\n`;
}

export async function clearAbiGroup(
  context: HookContext,
  config: Required<AbiExporterConfigEntry>,
) {
  const outputDirectory = path.resolve(context.config.paths.root, config.path);
  const outputExtension = config.format === 'typescript' ? '.ts' : '.json';

  if (!path.isAbsolute(outputDirectory)) {
    throw new HardhatPluginError(pkg.name, 'directory path must be absolute');
  }

  const files = (
    await fs.promises.readdir(outputDirectory, {
      recursive: true,
      withFileTypes: true,
    })
  )
    .filter((dirent) => dirent.isFile())
    .map((dirent) => path.resolve(dirent.parentPath, dirent.name));

  if (!fs.existsSync(outputDirectory)) {
    return;
  }

  await Promise.all(
    files.map(async (file) => {
      if (path.extname(file) !== outputExtension) {
        // ABIs must be stored as JSON or TS
        return;
      }

      const contents = await fs.promises.readFile(file, 'utf-8');

      if (outputExtension === '.json') {
        try {
          // attempt to parse ABI from file contents
          new Interface(contents);
        } catch (e) {
          // file is not an ABI - do not delete
          return;
        }
        await fs.promises.rm(file);
      } else if (outputExtension === '.ts') {
        if (!contents.includes(TAG)) {
          // file was not generated by plugin - do not delete
          return;
        }
        await fs.promises.rm(file);
      }
    }),
  );

  await deleteEmpty(outputDirectory);
}

export const exportAbiGroup = async (
  context: HookContext,
  config: Required<AbiExporterConfigEntry>,
) => {
  const outputDirectory = path.resolve(context.config.paths.root, config.path);

  if (outputDirectory === context.config.paths.root) {
    throw new HardhatPluginError(
      pkg.name,
      'resolved path must not be root directory',
    );
  }

  const outputData: { destination: string; contents: string }[] = [];

  const fullNames = Array.from(
    await context.artifacts.getAllFullyQualifiedNames(),
  );

  await Promise.all(
    fullNames.map(async (fullName) => {
      if (config.only.length && !config.only.some((m) => fullName.match(m)))
        return;
      if (config.except.length && config.except.some((m) => fullName.match(m)))
        return;

      let { abi, sourceName, contractName } =
        await context.artifacts.readArtifact(fullName);

      if (!abi.length) return;

      abi = abi.filter((element, index, array) =>
        config.filter(element, index, array, fullName),
      );

      let contents: string;

      if (config.format === 'json') {
        contents = JSON.stringify(abi, null, config.spacing);
      } else if (config.format == 'minimal') {
        abi = [new Interface(abi).format(FormatTypes.minimal)].flat();
        contents = JSON.stringify(abi, null, config.spacing);
      } else if (config.format == 'fullName') {
        abi = [new Interface(abi).format(FormatTypes.fullName)].flat();
        contents = JSON.stringify(abi, null, config.spacing);
      } else if (config.format === 'typescript') {
        contents = abiToTs(JSON.stringify(abi, null, config.spacing));
      } else {
        throw new HardhatPluginError(
          pkg.name,
          `Unknown format: ${config.format}`,
        );
      }

      const extension = config.format === 'typescript' ? '.ts' : '.json';
      const destination =
        path.resolve(outputDirectory, config.rename(sourceName, contractName)) +
        extension;

      outputData.push({ destination, contents });
    }),
  );

  outputData.reduce(
    (acc: { [destination: string]: string }, { destination, contents }) => {
      const previousContents = acc[destination];

      if (previousContents === contents) {
        throw new HardhatPluginError(
          pkg.name,
          `multiple distinct contracts share same output destination: ${destination}`,
        );
      }

      acc[destination] = contents;
      return acc;
    },
    {},
  );

  if (config.clear) {
    await clearAbiGroup(context, config);
  }

  await Promise.all(
    outputData.map(async ({ destination, contents }) => {
      await fs.promises.mkdir(path.dirname(destination), { recursive: true });
      await fs.promises.writeFile(destination, contents, { flag: 'w' });
    }),
  );
};
