import pkg from '../../package.json';
import { AbiExporterConfig, AbiExporterConfigEntry } from '../types.js';
import { Interface } from '@ethersproject/abi';
import deleteEmpty from 'delete-empty';
import fs from 'fs';
import { HookContext } from 'hardhat/types/hooks';
import path from 'path';

const TS_TAG = `// this file was automatically generated by ${pkg.name} - do not modify`;

export const clearAbi = async (
  context: HookContext,
  configEntries: AbiExporterConfig,
) => {
  const entries = configEntries.filter((entry) => entry.clear);

  await Promise.all(entries.map((entry) => clearAbiGroup(context, entry)));
};

const clearAbiGroup = async (
  context: HookContext,
  config: AbiExporterConfigEntry,
) => {
  const outputDirectory = path.resolve(context.config.paths.root, config.path);

  if (!fs.existsSync(outputDirectory)) {
    return;
  }

  // recursively get all files from directory

  const files = (
    await fs.promises.readdir(outputDirectory, {
      recursive: true,
      withFileTypes: true,
    })
  )
    .filter((dirent) => dirent.isFile())
    .map((dirent) => path.resolve(dirent.parentPath, dirent.name));

  // validate file contents and delete

  await Promise.all(
    files.map(async (file) => {
      const contents = await fs.promises.readFile(file, 'utf-8');

      if (path.extname(file) === '.json') {
        try {
          // attempt to parse ABI from file contents
          new Interface(contents);
        } catch (e) {
          // file is not an ABI - do not delete
          return;
        }
      } else if (path.extname(file) === '.ts') {
        if (!contents.includes(TS_TAG)) {
          // file was not generated by plugin - do not delete
          return;
        }
      } else {
        // ABIs must be stored as JSON or TS
        return;
      }

      await fs.promises.rm(file);
    }),
  );

  // delete the directory if it's empty

  await deleteEmpty(outputDirectory);
};
