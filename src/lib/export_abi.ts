import pkg from '../../package.json';
import { AbiExporterConfig, AbiExporterConfigEntry } from '../types.js';
import { clearAbi } from './clear_abi.js';
import { FormatTypes, Interface } from '@ethersproject/abi';
import fs from 'fs';
import { HardhatPluginError } from 'hardhat/plugins';
import { HookContext } from 'hardhat/types/hooks';
import path from 'path';

const TS_TAG = `// this file was automatically generated by ${pkg.name} - do not modify`;

export const exportAbi = async (
  context: HookContext,
  configEntries: AbiExporterConfig,
) => {
  await clearAbi(context, configEntries);

  await Promise.all(
    configEntries.map((entry) => exportAbiGroup(context, entry)),
  );
};

const exportAbiGroup = async (
  context: HookContext,
  config: AbiExporterConfigEntry,
) => {
  const outputDirectory = path.resolve(context.config.paths.root, config.path);

  // validate that the output directory is not the Hardhat root directory to prevent accidental file deletion

  if (outputDirectory === context.config.paths.root) {
    throw new HardhatPluginError(
      pkg.name,
      'resolved path must not be root directory',
    );
  }

  // get list of all contracts and filter according to configuraiton

  const fullNames = Array.from(
    await context.artifacts.getAllFullyQualifiedNames(),
  ).filter((fullName) => {
    if (config.only.length && !config.only.some((m) => fullName.match(m)))
      return false;
    if (config.except.length && config.except.some((m) => fullName.match(m)))
      return false;
    return true;
  });

  // get contract artifacts

  const artifacts = await Promise.all(
    fullNames.map((fullName) => context.artifacts.readArtifact(fullName)),
  );

  // filter out 0-length ABIs and generate export file contents

  const outputData = artifacts
    .filter(({ abi }) => abi.length)
    .map((artifact) => {
      const { sourceName, contractName } = artifact;
      let { abi } = artifact;

      abi = abi.filter((element, index, array) =>
        config.filter(element, index, array, sourceName, contractName),
      );

      // format ABI using ethers presets
      const formatType = FormatTypes[config.format] ?? 'json';
      abi = [new Interface(abi).format(formatType)].flat();

      let contents = JSON.stringify(abi, null, config.spacing);

      if (config.format === 'typescript') {
        contents = `${TS_TAG}\nexport default ${contents} as const;\n`;
      }

      const extension = config.format === 'typescript' ? '.ts' : '.json';
      const destination =
        path.resolve(outputDirectory, config.rename(sourceName, contractName)) +
        extension;

      return { destination, contents };
    });

  // check for filename clashes among exported files

  outputData.reduce(
    (acc: { [destination: string]: string }, { destination, contents }) => {
      const previousContents = acc[destination];

      if (previousContents && previousContents !== contents) {
        throw new HardhatPluginError(
          pkg.name,
          `multiple distinct contracts share same output destination: ${destination}`,
        );
      }

      acc[destination] = contents;
      return acc;
    },
    {},
  );

  // write export files to disk

  await Promise.all(
    outputData.map(async ({ destination, contents }) => {
      await fs.promises.mkdir(path.dirname(destination), { recursive: true });
      await fs.promises.writeFile(destination, contents, { flag: 'w' });
    }),
  );
};
